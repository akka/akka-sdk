= Implementing Agents

include::ROOT:partial$include.adoc[]

image:ROOT:agent.png[Agent,width=100,float=left]An Agent interacts with an AI model to perform a specific task. It is typically backed by a large language model (LLM). It maintains contextual history in a session memory, which may be shared between multiple agents that are collaborating on the same goal. It may provide function tools and call them as requested by the model.

[#_effect_api]
== Agent's Effect API

The Agent's Effect defines the operations that Akka should perform when an incoming command is handled by an Agent.

An Agent Effect can either:

* define model
* specify system, user messages and additional context
* configure session memory
* define available tools
* fail the step or reject a command by returning an error
* return an error message
* transform model response and reply to incoming commands

For additional details, refer to xref:concepts:declarative-effects.adoc[Declarative Effects].

== Skeleton

An agent implementation has the following code structure.

[source,java]
.{sample-base-url}/doc-snippets/src/main/java/com/example/application/MyAgent.java[MyAgent.java]
----
include::example$doc-snippets/src/main/java/com/example/application/MyAgent.java[tag=class]
----
<1> Create a class that extends `Agent`.
<2> Make sure to annotate such class with `@ComponentId` and pass a unique identifier for this agent type.
<3> Define the command handler method.

NOTE: The `@ComponentId` value `my-agent` is common for all instances of this agent and must be unique across the different components in the service.

An agent must have one command handler method that is public and returns `Effect<T>`, where `T` it the type of the reply. Alternatively it can return `StreamEffect` for xref:#_streaming_response[streaming responses].

The command handler may take one or no parameters as input. You can wrap multiple parameters in a record class.

There can only be one command handler because the agent is supposed to perform one single well-defined task.

== Model

Akka provides integration with several backend AI models, and you have to select which model to use. You can define a default model in `application.conf`:

[source,conf]
.src/main/resources/application.conf
----
akka.javasdk {
  agent {
    model-provider = openai

    openai {
      model-name = "gpt-4o-mini"
    }
  }
}
----

The default model will be used if the agent doesn't specify another model. Different agents can use different models by defining the `ModelProvider` in the Agent effect:

[source,java]
.{sample-base-url}/doc-snippets/src/main/java/com/example/application/MyAgent.java[MyAgent.java]
----
include::example$doc-snippets/src/main/java/com/example/application/MyAgent.java[tag=model]
----
<1> Define the model provider in code.

NOTE: With `ModelProvider.fromConfig` you can define several models in configuration and use different models in different agents.

Each model provider may have different settings. Available model providers are:

* `openai` - link:_attachments/api/akka/javasdk/agent/ModelProvider.OpenAi.html[`ModelProvider.OpenAi`]
* `anthropic` - link:_attachments/api/akka/javasdk/agent/ModelProvider.Anthropic.html[`ModelProvider.Anthropic`]

FIXME more providers ^

It is possible to plug in a custom model by implementing the link:_attachments/api/akka/javasdk/agent/ModelProvider.Custom.html[`ModelProvider.Custom`] interface and use it with `ModelProvider.custom`.

== Prompt

The prompt consists of essential instructions to the model.

* The system message provides system-level instructions to the AI model that defines its behavior and context. The system message acts as a foundational prompt that establishes the AI's role, constraints, and operational parameters. It is processed before user messages and helps maintain consistent behavior throughout the interactions.
* The user message represents the specific query, instruction, or input that will be processed by the model to generate a response.

An agent that suggests activities may have a prompt like:

[source,java]
.{sample-base-url}/doc-snippets/src/main/java/com/example/application/ActivityAgent.java[ActivityAgent.java]
----
include::example$doc-snippets/src/main/java/com/example/application/ActivityAgent.java[tag=prompt]
----
<1> Define the system message as a constant, but it could also be a method that adapts the system message based on the request.
<2> Use the system message in the effect builder.
<3> Define the user message for the specific request, and use in the effect builder.

=== Prompt template

As an alternative to hard-coded prompts, there is a built-in prompt template entity. The advantage of using the prompt template entity is that you can change the prompts at runtime without restarting or redeploying the service.

FIXME...

== Calling the Agent

Use the `ComponentClient` to call the agent from a Workflow, Endpoint or Consumer.

[source,java]
----
include::example$doc-snippets/src/main/java/com/example/application/ActivityAgent.java[tag=call]
----
<1> Use `forAgent`.
<2> Define the identifier of the session that the agent participates in.

The session id is used by the xref:#_session_memory[session memory], but it is also important for observability tracking and AI evaluation.

You can use a new random UUID for each call if the agent doesn't collaborate with other agents nor have a multi-step interaction with the AI model.

For more details about the `ComponentClient`, see xref:component-and-service-calls.adoc[].

== Drive the Agent from a workflow

Agents make external calls to the AI model and possibly other services, and therefore it is important to have solid error handling and durable execution steps when calling agents. In many cases it is a good recommendation to call agents from a xref:workflows.adoc[Workflow]. The workflow will automatically execute the steps in a reliable and durable way. This means that if a call in a step fails, it will be retried until it succeeds or the retry limit of the recovery strategy is reached and separate error handling can be performed. The state machine of the workflow is durable, which means that if the workflow is restarted for some reason it will continue from where it left off, i.e. execute the current non-completed step again.

A workflow will typically orchestrate several agents, which collaborate in achieving a common goal. We will look more at xref:#_multi_agent[multi-agent systems], but let's start with a workflow for the single activities agent.

[source,java]
----
include::example$doc-snippets/src/main/java/com/example/application/ActivityAgentManager.java[tag=all]
----
<1> Extend `Workflow`.
<2> The state can hold intermediate and final results, and it is durable.
<3> Inject the `ComponentClient`, which will be used when calling the agent.
<4> This workflow only has two command handler methods. One that starts the workflow with the initial user request,
<5> and one to retrieve the final answer.
<6> Define the steps of the workflow.
<7> The step that calls the `ActivitiesAgent`
<8> Call the agent with the `ComponentClient`
<9> Store the result from the agent.
<10> The workflow corresponds to an agent session.

The workflow itself will be instantiated by making a call to the `start` method from an endpoint or a consumer.

Keep in mind that AI requests are typically slow (many seconds), and you need to define the workflow timeouts accordingly. This is specified in the workflow step definition with:

[source,java]
----
.timeout(Duration.ofSeconds(60))
----

Additionally, you should define a workflow recovery strategy so that it doesn't retry failing requests infinitely. This is specified in the workflow definition with:

[source,java]
----
.defaultStepRecoverStrategy(maxRetries(2).failoverTo("error"))
----

More details in xref:workflows.adoc#_error_handling[Workflow timeouts and recovery strategy].

== Session memory

FIXME

== Structured responses

FIXME

- prompt instructions for json responses
- mapping of model response to another reply type

== Function tools

FIXME

== Use ComponentClient in an Agent

xref:java:setup-and-dependency-injection.adoc#_dependency_injection[Dependency injection] can be used in an
Agent. For example, injecting the `ComponentClient` to be able to enrich the request to the AI model with
information from entities or views may look like this:

[source,java]
.{sample-base-url}/doc-snippets/src/main/java/com/example/application/ActivityAgent.java[ActivityAgent.java]
----
include::example$doc-snippets/src/main/java/com/example/application/ActivityAgent.java[tag=di]
----
<1> Inject the `ComponentClient` as a constructor parameter.
<2> Retrieve preferences from an entity.
<3> Enrich the user message with the preferences.

This also illustrates the important point that the context of the request to the AI model can be built from additional information in the service and doesn't only have to come from the session memory.

== Streaming response

FIXME

- from endpoint serving UI
- SSE

== Multi-agent

A single agent performs one well-defined task. Several agents can collaborate to achieve a common goal. The agents should be orchestrated from a predefined workflow or a dynamically created plan.

=== Predefined workflow

Let's first look at how to define a workflow that orchestrates several agents in a predefined steps. This is similar to the xref:#_drive_the_agent_from_a_workflow[`ActivitiesAgentManager`] that was illustrated above, but it uses both the `WeatherAgent` and the `ActivitiesAgent`. First it retrieves the weather forecast and then it finds suitable activities.

[source,java]
----
include::example$doc-snippets/src/main/java/com/example/application/AgentTeam.java[tag=all]
----
<1> The workflow starts by asking for the weather forecast.
<2> Weather forecast is retrieved by the `WeatherAgent`, which must extract the location and date from the user query.
<3> The forecast is stored in the state of the workflow.
<4> The forecast is included in the request to the `ActivitiesAgent`.
<5> The final result is stored in the workflow state.

In image:concepts:steps-4.svg[width=20] we explicitly include the forecast in the request to the `ActivitiesAgent`. That is not strictly necessary because the agents share the same session memory and thereby the `ActivitiesAgent` will already have the weather forecast in the context that is sent to the AI model.

The workflow will automatically execute the steps in a reliable and durable way. This means that if a call in a step fails, it will be retried until it succeeds or the retry limit of the recovery strategy is reached and separate error handling can be performed. The state machine of the workflow is durable, which means that if the workflow is restarted for some reason it will continue from where it left off, i.e. execute the current non-completed step again.

=== Dynamic plan

To create a more flexible and autonomous agentic system you want to analyze the problem and dynamically come up with a plan. The agentic system should identify the tasks to achieve the goal by itself. Decide which agents to use and in which order to execute them. Coordinate input and output between agents and adjust the plan along the way.

There are several approaches for the planning, such as using deterministic algorithms or using AI also for the planning. We will look at how we can use AI for analyzing a request, selecting agents and in which order to use them.

We split the planning into two steps and use two separate agents for these tasks. It's not always necessary to use several steps for the planning. You have to experiment with what works best for your problem domain.

. Select agents that are useful for a certain problem.
. Decide in which order to use the agents and give each agent precise instructions for its task.

The `Selector` agent decides which agents to use:

[source,java]
.{sample-base-url}/multi-agent/src/main/java/demo/multiagent/application/agents/Selector.java[Selector.java]
----
include::example$multi-agent/src/main/java/demo/multiagent/application/agents/Selector.java[tag=all]
----
<1> The `AgentRegistry` contains information about all agents.
<2> Select the agents with the role `"worker"`.
<3> Detailed instructions and include descriptions (as json) of the agents.

The information about the agents in the `AgentRegistry` comes from the `@ComponentId` and `@AgentDescription` annotations. When using it for planning like this it is important that the agents define those descriptions that the LLM can use to come up with a good plan.

The `WeatherAgent` has:
[source,java]
.{sample-base-url}/multi-agent/src/main/java/demo/multiagent/application/agents/WeatherAgent.java[WeatherAgent.java]
----
include::example$multi-agent/src/main/java/demo/multiagent/application/agents/WeatherAgent.java[tag=description]
----

The `WeatherAgent` has:
[source,java]
.{sample-base-url}/multi-agent/src/main/java/demo/multiagent/application/agents/ActivityAgent.java[ActivityAgent.java]
----
include::example$multi-agent/src/main/java/demo/multiagent/application/agents/ActivityAgent.java[tag=description]
----

Note that in image:concepts:steps-2.svg[width=20] of the `Selector` we retrieve a subset of the agents with a certain role. This role is also defined in the `@AgentDescription` annotation.

The result from the `Selector` is a list of agent ids:
[source,java]
.{sample-base-url}/multi-agent/src/main/java/demo/multiagent/domain/AgentSelection.java[AgentSelection.java]
----
include::example$multi-agent/src/main/java/demo/multiagent/domain/AgentSelection.java[tag=all]
----

After selecting agents, we use a `Planner` agent to decide in which order to use the agents and what precise request that each agent should receive to perform its single task.

[source,java]
.{sample-base-url}/multi-agent/src/main/java/demo/multiagent/application/agents/Planner.java[Planner.java]
----
include::example$multi-agent/src/main/java/demo/multiagent/application/agents/Planner.java[tag=all]
----
<1> Lookup the agent information for the selected agents from the `AgentRegistry.
<2> Detailed instructions and include descriptions (as json) of the agents.

That's the two agents that perform the planning, but we also need to connect them and execute the plan. This orchestration is the job of a workflow, called `AgentTeam`.

[source,java]
.{sample-base-url}/multi-agent/src/main/java/demo/multiagent/application/AgentTeam.java[AgentTeam.java]
----
include::example$multi-agent/src/main/java/demo/multiagent/application/AgentTeam.java[tag=plan]
----
<1> It's a workflow, with reliable and durable execution.
<2> The steps are select - plan - execute - summarize.
<3> The workflow starts by selecting agents
<4> which is performed by the `Selector` agent.
<5> Continue with making the actual plan
<6> which is performed by the `Planner` agent, using the selection from the previous step.
<7> Continue with executing the plan.
<8> Take the next task in the plan.
<9> Call the agent for the task.
<10> Continue executing the plan until no tasks are remaining.

When executing the plan and calling the agents we know the id of the agent to call, but not the agent class. It can be the `WeatherAgent` or `ActivityAgent`. Therefore, we can't use the ordinary `method` of the `ComponentClient. Instead, we use the `dynamicCall` with the id of the agent. We don't have compile time safety for those dynamic calls, but we know that these agents take a String parameter and return AgentResponse. If we used it with the wrong types, it would be a runtime exception.

[source,java]
----
include::example$multi-agent/src/main/java/demo/multiagent/application/AgentTeam.java[tag=dynamicCall]
----

You find the full source code for this multi-agent sample in the link:https://github.com/akka-samples/multi-agent[akka-samples/multi-agent Github Repository].

== Testing the Agent

FIXME
