= Akka SDK

include::ROOT:partial$include.adoc[]
include::partial$attributes.adoc[]

Building services with the Akka SDK leads you into embracing proven design patterns that enable your apps to remain responsive to change. It frees you from infrastructure concerns and lets you focus on the application logic.

With its few, concise components, the Akka SDK is easy to learn, and you can develop services in quick, iterative steps by running your code locally with full insight through Akka's console.

Akka services let you build REST endpoints with flexible access control and multiple ways to expose these endpoints to their consuming systems or applications. Akka is secure by default, and you explicitly express the desired access through code and configuration.

Akka encapsulates data together with the logic to access and modify it. The data itself is expressed in regular Java records (plain old Java objects). The same goes for the events that change the data, these are expressed in pure Java to reflect business events that lead to data updates. Akka enables you to build fully event-driven services by combining logic and data into one thing: entities.

Data and changes to it are managed by Akka's runtime without the need to manage database storage. Changes to your data can be automatically replicated to multiple places, not only within a single service, but also across applications and even cloud providers. An SQL-like language lets you design read access that ensures the data is properly indexed for your application needs.

Integrations with message systems like Kafka are already built-in and the Akka SDK enables message consumers to listen to topics and queues.

== Prerequisites

The following are required to develop services with the Akka SDK:

Java:: Java {java-version} or later.

Apache Maven:: https://maven.apache.org/[Apache Maven {tab-icon}, window="new"] is the recommended build tool with the Akka SDK.

== A simple service

:TODO: Graph view of the customer registry service with endpoints, entities and views.

This tiny service exposes its REST API (POST, PATCH, GET,...) through Endpoints.
The data and changes to it are defined as Java records describing the domain that are managed as an Entity.
To query the data, the service offers Views.

== Getting Started

Follow our xref:java:getting-started.adoc["Getting started with the Akka SDK"] guide to implement your first service. If you prefer to first explore working example code, you can check out the https://docs.kalix.io/samples/index.html[beginner samples].

On the other hand, if you would rather spend some time exploring our documentation, here are some main features you will find in this section:

* xref:java:endpoints.adoc[REST Endpoints]
* xref:java:value-entity.adoc[Key Value Entities]
* xref:java:event-sourced-entities.adoc[Event Sourced Entities]
* xref:java:views.adoc[Views]
* xref:java:publishing-subscribing.adoc[Consumers]
* xref:java:timed-actions.adoc[Timed Actions]
* xref:java:workflows.adoc[Workflows]
* xref:java:actions.adoc[Actions]


[#_dependency_injection]
=== Dependency Injection

:TODO: Should this section be kept?

*Actions*, *Entities* and *Views* are all Kalix components, and they get special treatment.

When your application starts, it will scan the classpath for any class extending one of the Kalix components. Each time such a component is found, it's analysed in order to generate the necessary metadata that Kalix requires to be able to interact with them. The component is then registered to Kalix and made available to the Runtime through Kalix internal protocol.

It's important to understand that interacting directly with a Kalix component is NOT possible. All interactions must happen through the Runtime since that's how Kalix manages state and distribution. Therefore, it's not possible to use dependency injection to inject Kalix components inside other components and doing so will raise a runtime error.

On the other hand, it is possible to inject non-Kalix classes into Kalix components. Any Spring bean defined in your application can be injected into a Kalix component. However, you must keep in mind that Kalix components can only receive other dependencies through constructor injection.

For more details on how Kalix manage state and distribution, consult the https://docs.kalix.io/services/programming-model.html[Programming model] page.

=== Spring Repositories

In Kalix, data storage and retrieval follows the https://developer.lightbend.com/docs/akka-platform-guide/concepts/cqrs.html[Command Query Responsibility Segregation (CQRS)] pattern. In CQRS, we work with two models. One that is designed for writes, often called the command-model, and one that is optimized for reads, also known as the query-model.

The persistent Kalix entities (xref:java:event-sourced-entities.adoc[Event Sourced Entity] and xref:java:value-entity.adoc[Key Value Entity]) represent the command-model in the CQRS pattern. They receive `Commands` and mutate data in their own transaction.

Data produced by entities can be propagated to xref:java:views.adoc[Views] in order to generate query-models, also known as view-models. Views are indexed representations of your model. You can query your data using different fields, while Entities are only accessible by their entity id.

In both cases, Kalix manages all persistence aspects and your code only need to specify the business logic.
