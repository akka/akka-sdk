= Designing gRPC Endpoints

include::ROOT:partial$include.adoc[]

An Endpoint is a component that creates an externally accessible API. Endpoints are how you expose your services to the outside world. Two different types of endpoints are available: HTTP endpoints and gRPC endpoints. In this page, we will focus on gRPC endpoints.

gRPC Endpoint components make it possible to conveniently define public APIs accepting and responding in protobuf --
a binary, typed protocol which is designed to handle evolution of a service over time.

== Basics ==
To define a gRPC Endpoint component, you start by defining a `.proto` file that defines the service and its messages
in `src/main/proto` of the project.

[source,protobuf]
.{sample-base-url}/grpc-shopping-cart-quickstart/src/main/proto/shoppingcart/api/shopping_cart_endpoint.proto[shopping_cart_endpoint.proto]
----
include::example$grpc-shopping-cart-quickstart/src/main/proto/shoppingcart/api/shopping_cart_endpoint.proto[tag=minimal]
----

When compiling the project, a Java interface for the service is generated `shoppingcart.api.proto.ShoppingCartEndpoint`. Define a class implementing this interface in the `api` package of your project
and annotate the class with `@GrpcEndpoint`:

[source,java]
----
@GrpcEndpoint // <1>
public class ShoppingCartEndpointImpl implements ShoppingCartEndpoint {

  @Override
  public CompletionStage<ShoppingCartEndpointOuterClass.ShoppingCart> getCart(GetCartRequest in) {
    var protoCartBuilder = ShoppingCartEndpointOuterClass.ShoppingCart.newBuilder(); // <2>
    protoCartBuilder.setCartId(in.getCartId());
    protoCartBuilder.setCheckedOut(false);
    return CompletableFuture.completedFuture(protoCartBuilder.build()); // <3>
  }
}
----
<1> Mark class as a gRPC endpoint and implementing the generated interface `ShoppingCartEndpoint`.
<2> Create a new `ShoppingCart` protobuf message and set the `cartId` and `checkedOut` fields.
<3> Return a `CompletionStage` that is completed with the `ShoppingCart` protobuf message.

NOTE: This implementation does not interact with any other components and has an hard-coded response for simplification purposes. Interacting with other components is covered in the next section.

=== Error responses ===

The gRPC protocol has different status codes to signal that something went wrong with a request, for example `INVALID_ARGUMENT` to signal that the request was malformed.

To signal an error in the response, throw a `GrpcServiceException` as shown in the example below:
[source,java]
.{sample-base-url}/grpc-shopping-cart-quickstart/src/main/java/shoppingcart/api/ShoppingCartEndpointImpl.java[ShoppingCartEndpointImpl.java]
----
include::example$grpc-shopping-cart-quickstart/src/main/java/shoppingcart/api/ShoppingCartEndpointImpl.java[tag=exception]
----

ifdef::todo[TODO: add more details on exception handling after fix for bubble up and details in dev mode]

== Interacting with other components ==

Endpoints are commonly used to interact with other components in a service. This is done through
the `akka.javasdk.client.ComponentClient`. If the constructor of the endpoint class has a parameter of this type,
it will be injected by the SDK and can then be available for use when processing requests. Let's see how this is done:

[source,java]
.{sample-base-url}/grpc-shopping-cart-quickstart/src/main/java/shoppingcart/api/ShoppingCartEndpointImpl.java[ShoppingCartEndpointImpl.java]
----
include::example$grpc-shopping-cart-quickstart/src/main/java/shoppingcart/api/ShoppingCartEndpointImpl.java[tag=endpoint-component-interaction]
----
<1> Mark class as a gRPC endpoint and implementing the generated interface `ShoppingCartEndpoint`.
<2> Accept the `ComponentClient` and keep it in a field.
<3> Use the component client to interact with an Event Sourced Entity that represents the shopping cart, identified by `cartId`.
<4> Transform the result from the component client to the external response.

For more details see xref:component-and-service-calls.adoc[].

== Streaming

gRPC supports streaming requests and responses, with which either the client or the server (or both) can send multiple messages. In this section, we will show how to stream the results of a request but the remaining combinations are similar.

To stream the results of a request, mark the return type of the method as `stream` in the `.proto` file:

[source,protobuf]
.{sample-base-url}/event-sourced-customer-registry/src/main/proto/customer/api/customer_grpc_endpoint.proto[customer_grpc_endpoint.proto]
----
include::example$event-sourced-customer-registry/src/main/proto/customer/api/customer_grpc_endpoint.proto[tag=streaming-output]
----

Then, the method in the endpoint interface will need to construct and return a `Stream`:

[source,java]
.{sample-base-url}/event-sourced-customer-registry/src/main/java/customer/api/CustomerGrpcEndpointImpl.java[CustomerGrpcEndpointImpl.java]
----
include::example$event-sourced-customer-registry/src/main/java/customer/api/CustomerGrpcEndpointImpl.java[tag=customerByEmailStream]
----

NOTE: The above example depends on existing a View component that also returns a `Stream` of `Customer` messages. See xref:views.adoc#_streaming_the_result[] for more details.

== Testing the Endpoint

To exercise a gRPC endpoint, the testkit contains methods to get a gRPC client for calling the methods of the endpoint:

[source,java]
.{sample-base-url}/grpc-shopping-cart-quickstart/src/test/java/shoppingcart/ShoppingCartGrpcIntegrationTest.java[ShoppingCartGrpcIntegrationTest.java]
----
include::example$grpc-shopping-cart-quickstart/src/test/java/shoppingcart/ShoppingCartGrpcIntegrationTest.java[tag=sample-it]
----

By default, if ACLs are defined, the testkit client is authenticated as if it was the service itself calling the endpoint,
but there is also an overload to `getGrpcEndpointClient` that takes a `Principal` parameter for specifying what principal
client should seem like from the endpoints point of view, for example to simulate another service `Principal.localService("other-service")`
or a request coming from the public internet `Principal.INTERNET`.