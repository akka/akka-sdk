= Timed Actions
:sample-base-url: https://github.com/lightbend/akka-javasdk/blob/main/samples

Timers allow for scheduling calls in the future. For example, to verify that some process have been completed or not.

Timers are persisted by the xref:reference:glossary.adoc#runtime[Akka Runtime] and are guaranteed to run at least once.

When a timer is triggered, the scheduled call is executed. If successfully executed, the timer completes and is automatically removed. In case of a failure, the timer is rescheduled with a delay of 3 seconds. This process repeats until the call succeeds.

**Timer features**:

* Timers are guaranteed to run at least once.
* Timers can be scheduled to run at any time in the future.
* Timers can be cancelled.
* Timers are automatically removed once successfully completed.
* Timers are re-scheduled in case of failures.
* Timers failing can be limited to a maximum number of retries.

**Timer limitations**:

* Timers can only call other components (e.g., Entities, Workflows, Timed Actions). External service calls must be wrapped by Timed Action component.
* Maximum allowed timer command payload is 1024 bytes.

== Order Entity

To demonstrate its functionality, let's consider an Ordering Service composed of a xref:key-value-entities.adoc[Key Value Entity] and a Timed Action component. The Timed Action will orchestrate the cancellation task, which requires a call to an external service.

Users can place an order, but the order must be confirmed within a period of time. You can think of it as an Ordering Food application where the restaurant needs to confirm if it can accept the order. If no confirmation is sent within some pre-defined period of time, the order is automatically cancelled.

Let's have a look on how the Order Entity can be implemented.

[source,java,indent=0]
.{sample-base-url}/reliable-timers/src/main/java/com/example/application/OrderEntity.java[OrderEntity.java]
[source,java]
----
include::example$reliable-timers/src/main/java/com/example/application/OrderEntity.java[tag=order]
----
<1> The `placeOrder` method is responsible for the creation of an order.
<2> Note that we set the `placed` field to true.
<3> When confirming an Order, we must ensure that the Order was created before.
<4> If the Order was never created, it returns `NotFound`.
<5> Cancelling an Order that was never placed also returns `NotFound`.
<6> While cancelling an already confirmed order returns `Invalid`.
<7> Finally, if the Order is placed, but not confirmed, the cancel method resets the order to the `emptyState`.

== Timed Action

As said before, the `OrderEndpoint` will , receiving incoming messages, running some logic and then calling the Order Entity as needed.

=== Scheduling a timer

We will first look at `OrderEndpoint` which acts as a controller ahead of the Order Entity. Before delegating the request to the Order Entity, the Endpoint creates a timer.

[source,java,indent=0]
.{sample-base-url}/reliable-timers/src/main/java/com/example/api/OrderEndpoint.java[OrderEndpoint.java]
----
include::example$reliable-timers/src/main/java/com/example/api/OrderEndpoint.java[tags=timers;place-order]
----
<1> First we generate a random identifier for the OrderEntity. It will be used to identify the Order, but also as a unique name for the timer.
<2> Call the timers API to register a new timer. Note that it returns `CompletionStage<Done>`. A successful completion means that Akka registered the timer.
<3> Order id is used to generate a unique name for the timer.
<4> Set the delay we want for the timer to trigger.
<5> Schedule a deferred call to the Timed Action component. We will cover it in a while.
<6> Finally, compose the `timerRegistration` CompletionStage with a call to `OrderEntity` to place the order.

In a nutshell, we first requested Akka to register a timer. When it completes, we know that the timer is persisted and will run at the specified time. You then proceed by placing the order.

The `DeferredCall` returned from the component client `deferred` method is a way to defer the call to Akka components. It can be persisted and executed at a later time.

The sequence of actions is important here. If we had called the entity first and then registered the timer, the Order could have been placed and the timer registration could have failed due to some network issue for example. In such a case, we would end up with an Order without an expiration timer.

But the inverse is also true. There is still the risk of registering the timer and then failing to place the Order. However, the implementation of the `expire` method can take that into account.

=== Handling the timer call

Let's have a look at the `OrderTimedAction.expire` method implementation.

[source,java,indent=0]
.{sample-base-url}/reliable-timers/src/main/java/com/example/application/OrderTimedAction.java[OrderTimedAction.java]
----
include::example$reliable-timers/src/main/java/com/example/application/OrderTimedAction.java[tags=expire-order]
----
<1> Set `@ComponentId` annotation for the component.
<2> Extend `TimedAction` class.
<3> The effect will return an asynchronous call to the `OrderEntity` component to cancel the Order.
<4> If the `CompletionStage` completes with a failure, we must decide if we will recover the call or not. If we recover it, the timer will be considered as completed. If we let the call fail, the timer will be re-scheduled. The `OrderEntity.cancel` implementation, except `Ok`, can return `NotFound` or `Invalid` responses. In both cases, we can consider that the timer has become obsolete and don't need to be rescheduled, therefore we recover the call.

For all other possible errors, the call to `OrderTimedAction.expire` will fail and the timer will be re-scheduled.

IMPORTANT: Whenever we implement a method that is called from a timer, we need to carefully handle errors inside that method. Failing to do so may cause the timer to keep re-scheduling. Therefore, we should ensure that any failure is properly handled and only propagated if the intention is to re-try the call.

=== Failures and retries

If a scheduled call fails it will be retried, retries are backed off exponentially, starting at 3 seconds and can
reach a maximum backoff of 30 seconds if consecutive retries keep failing.

The default is to keep retrying indefinitely, but it is possible to limit the number of retries before giving up via the `startSingleTimer` overload parameter `maxRetries`.

=== Cancelling a timer

Next, we can have a look at confirmation and cancellation endpoint implementations.

[source,java,indent=0]
.{sample-base-url}/reliable-timers/src/main/java/com/example/api/OrderEndpoint.java[OrderEndpoint.java]
----
include::example$reliable-timers/src/main/java/com/example/api/OrderEndpoint.java[tags=timers;confirm-cancel-order]
----
<1> Call the Order entity to execute confirmation.
<2> If it succeeds, remove the timer.

In both methods, we call proper `OrderEntity` method and when it completes, we cancel the timer.

Once more, the ordering is important. It's not a problem if the call to cancel the timer fails. As we have seen in the `OrderEntity.expireOrder` implementation, if the timer is triggered, but is obsolete, we will properly recover from it and signal to Akka that the timer can be removed.

TIP: We could have completely ignored the timer cancellation when handling the confirmation or the cancelling. The registered timer would then be triggered at some point later and the implementation is ready to handle gracefully this case. However, it's always of good measure to do some housekeeping to save resources.
