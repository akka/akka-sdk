= Table Updaters

Table Updaters are the core components that define and maintain view tables. They subscribe to events or state changes from entities and transform this data into queryable views. This page explains how to define and use Table Updaters in your View components.

== What are Table Updaters?

A Table Updater is a Java class defined inside your View that:

1. Specifies a data source (entity or topic)
2. Defines the structure of a view table
3. Contains logic for transforming incoming data into view rows
4. Handles updates, deletes, and other operations on the view table

== Basic Structure

A Table Updater is defined as a static inner class inside your View:

[source,java]
----
@ComponentId("customer-view")
public class CustomerView extends View {

  @Table("customers") // Optional table name
  @Consume.FromKeyValueEntity(CustomerEntity.class)
  public static class Customers extends TableUpdater<Customer> {
    // Transformation methods go here
  }

  // Query methods go here
}
----

== Table Naming

Table names can be specified explicitly with the `@Table` annotation:

[source,java]
----
@Table("customers")
public static class Customers extends TableUpdater<Customer> { }
----

If not specified, the table name defaults to a name derived from:

* The component ID for single-table views
* The class name of the Table Updater for multi-table views

== Data Sources

Table Updaters can consume data from different sources:

=== Key Value Entities

Subscribe to state changes from Key Value Entities:

[source,java]
----
@Consume.FromKeyValueEntity(CustomerEntity.class)
public static class CustomerUpdater extends TableUpdater<Customer> { }
----

=== Event Sourced Entities

Subscribe to events from Event Sourced Entities:

[source,java]
----
@Consume.FromEventSourcedEntity(CustomerEntity.class)
public static class CustomerEvents extends TableUpdater<CustomerView> { }
----

=== Topics

Subscribe to messages from a topic:

[source,java]
----
@Consume.FromTopic("customer-events")
public static class CustomerFromTopic extends TableUpdater<Customer> { }
----

== Generic Type Parameter

The generic type parameter of `TableUpdater<T>` defines the structure of each row in the view table:

[source,java]
----
public static class Customers extends TableUpdater<Customer> { }
----

This means each row in the view table will have the structure of the `Customer` class.

== Transformation Methods

Table Updaters can include methods to transform incoming data:

=== For Key Value Entities

For Key Value Entities, a default transformation (storing the entire state) is used if no transformation method is provided:

[source,java]
----
@Consume.FromKeyValueEntity(CustomerEntity.class)
public static class Customers extends TableUpdater<Customer> { }
----

You can define custom transformation with an `onUpdate` method:

[source,java]
----
@Consume.FromKeyValueEntity(CustomerEntity.class)
public static class CustomerSummaries extends TableUpdater<CustomerSummary> {

  public Effect<CustomerSummary> onUpdate(Customer customer) {
    return effects().updateRow(
      new CustomerSummary(
        updateContext().eventSubject().get(),
        customer.name(),
        customer.email()
      )
    );
  }
}
----

=== For Event Sourced Entities

For Event Sourced Entities, you need to define how events transform the view:

[source,java]
----
@Consume.FromEventSourcedEntity(CustomerEntity.class)
public static class CustomersByName extends TableUpdater<CustomerRow> {

  public Effect<CustomerRow> onEvent(CustomerEvent event) {
    return switch (event) {
      case CustomerEvent.CustomerCreated created ->
        effects().updateRow(new CustomerRow(
          updateContext().eventSubject().get(),
          created.name(),
          created.email(),
          created.address()
        ));

      case CustomerEvent.NameChanged nameChanged ->
        effects().updateRow(rowState().withName(nameChanged.newName()));

      case CustomerEvent.AddressChanged addressChanged ->
        effects().updateRow(rowState().withAddress(addressChanged.address()));
    };
  }
}
----

=== For Topics

For Topics, define how to transform messages into view rows:

[source,java]
----
@Consume.FromTopic("customer-events")
public static class CustomerMessages extends TableUpdater<Customer> {

  public Effect<Customer> onMessage(CustomerMessage message) {
    String customerId = messageContext().metadata().asCloudEvent().subject().get();
    return effects().updateRow(
      new Customer(customerId, message.name(), message.email())
    );
  }
}
----

== Effect Types

Table Updater methods return `Effect` objects that define what happens to the view table:

=== Update Row

Updates or inserts a row in the view table:

[source,java]
----
return effects().updateRow(newRowState);
----

=== Delete Row

Deletes the current row from the view table:

[source,java]
----
return effects().deleteRow();
----

=== Ignore

Makes no changes to the view table:

[source,java]
----
return effects().ignore();
----

== Accessing Context

Table Updaters provide context about the current update:

=== Update Context

Access information about the event or state change:

[source,java]
----
// Get the entity ID
String entityId = updateContext().eventSubject().get();

// Check if the event originated in the local region
boolean isLocal = updateContext().hasLocalOrigin();

// Get the region where the event originated
String originRegion = updateContext().originRegion();
----

=== Row State

Access the current state of the row being updated:

[source,java]
----
// For immutable types, create a new instance with updated fields
return effects().updateRow(rowState().withName(nameChanged.newName()));

// For mutable types, modify and return
CustomerRow current = rowState();
current.setName(nameChanged.newName());
return effects().updateRow(current);
----

== Multi-Table Views

A single View can define multiple Table Updaters to create a view with multiple tables:

[source,java]
----
@ComponentId("shop-view")
public class ShopView extends View {

  @Table("customers")
  @Consume.FromEventSourcedEntity(CustomerEntity.class)
  public static class Customers extends TableUpdater<Customer> {
    // Customer transformation methods
  }

  @Table("products")
  @Consume.FromEventSourcedEntity(ProductEntity.class)
  public static class Products extends TableUpdater<Product> {
    // Product transformation methods
  }

  @Table("orders")
  @Consume.FromKeyValueEntity(OrderEntity.class)
  public static class Orders extends TableUpdater<Order> {
    // Order transformation methods
  }

  // Query methods that can join across tables
  @Query("""
    SELECT c.name, o.*, p.name AS productName
    FROM customers AS c
    JOIN orders AS o ON c.id = o.customerId
    JOIN products AS p ON o.productId = p.id
    WHERE c.id = :customerId
    """)
  public QueryEffect<CustomerOrders> getCustomerOrders(String customerId) {
    return queryResult();
  }
}
----

== Handling Deletes

To handle entity deletions, use the `@DeleteHandler` annotation:

=== For Key Value Entities

[source,java]
----
@Consume.FromKeyValueEntity(CustomerEntity.class)
public static class Customers extends TableUpdater<Customer> {

  @DeleteHandler
  public Effect<Customer> onDelete() {
    return effects().deleteRow();
  }
}
----

=== For Event Sourced Entities

Handle delete events explicitly:

[source,java]
----
@Consume.FromEventSourcedEntity(CustomerEntity.class)
public static class Customers extends TableUpdater<Customer> {

  public Effect<Customer> onEvent(CustomerEvent event) {
    return switch (event) {
      case CustomerEvent.CustomerDeleted deleted -> effects().deleteRow();
      // Handle other events
    };
  }
}
----

== Notes

* A View can contain multiple Table Updaters, each creating a separate table
* Each Table Updater can subscribe to a different entity or topic
* The generic type parameter defines the structure of the view table
* Table Updaters are declarative - they define what happens for each event or state change
* View tables are eventually consistent with their source entities
* Multi-region replication is handled automatically at the entity level

== Related Features

* xref:reference:views/concepts/data-types.adoc[Data Types] - Types supported in views
* xref:reference:views/syntax/from.adoc[FROM clause] - Referencing tables in queries
* xref:reference:views/syntax/join.adoc[JOIN clause] - Combining data from multiple tables
* xref:reference:views/concepts/advanced-views.adoc[Advanced Views] - Creating complex views
