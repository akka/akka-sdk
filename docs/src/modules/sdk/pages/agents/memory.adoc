= Managing session memory

include::ROOT:partial$include.adoc[]

Session Memory provides a history mechanism that enables agents to maintain context across multiple interactions. This feature is essential for building agents that can remember previous exchanges with users, understand context, and provide coherent responses over time.

When an agent interacts with an AI model, both the user message and the AI response are automatically stored in the session memory. These messages are then included as additional context in subsequent requests to the model, allowing it to reference previous parts of the interaction.

The session memory is:

* Identified by a session ID that links related interactions
* Shared between multiple agents if they use the same session ID
* Persisted as an event-sourced entity
* Automatically managed by the Agent

== Session memory configuration

By default, session memory is enabled for all agents. You can configure it globally in your `application.conf`:

[source,conf,indent=0]
----
akka.javasdk.agent.memory {
  enabled = true
  limited-window {
    max-size = 156KiB # max history size before oldest message start being removed
  }
}
----

Or you can configure memory behavior for specific agent interactions using the `MemoryProvider` API.

Example with `limitedWindow` memory provider:
[source,java,indent=0]
----
include::example$doc-snippets/src/main/java/com/example/application/MyAgentMore.java[tag=read-last]
----


Example disabling session memory for the agent:
[source,java,indent=0]
----
include::example$doc-snippets/src/main/java/com/example/application/MyAgentMore.java[tag=no-memory]
----

== Different memory providers

The link:_attachments/api/akka/javasdk/agent/MemoryProvider.html[`MemoryProvider`] interface allows you to control how session memory behaves:

* `MemoryProvider.none()` - Disables both reading from and writing to session memory
* `MemoryProvider.limitedWindow()` - Configures memory with options to, e.g.:
  ** Setup **read only** memory, in which the agent reads the memory but does not allow write any interactions to it. This is ideal for multi-agent sessions where some agents can store memory and others can't.
  ** Setup **write only** memory, in which the agent register the interactions to the session memory but does not take those in consideration when processing the user message.
  ** Limit the amount of messages used as context in each interaction, i.e. use only the last N number of messages for context (good for token usage control).
* `MemoryProvider.custom()` - Allows you to provide a custom implementation for the `SessionMemory` interface and store the session memory externally in a database / service of your preference.

== Accessing session memory

The default implementation of Session Memory is backed by a regular xref:sdk:event-sourced-entities.adoc[Event Sourced Entity] called `SessionMemoryEntity`, which allows you to interact directly with it as you would do with any other entities in your application. This includes the possibility to directly modify or access it through the `ComponentClient` but also the ability to subscribe to changes in the session memory, as shown below:

[source,java,indent=0]
.{sample-base-url}/doc-snippets/src/main/java/com/example/application/SessionMemoryConsumer.java[SessionMemoryConsumer.java]
----
include::example$doc-snippets/src/main/java/com/example/application/SessionMemoryConsumer.java[tag=consumer]
----

This can be useful for more granular control over token usage but also to allow external integrations and analytics over these details.

== Compaction

You can update the session memory to reduce the size of the history. One technique is to let an LLM summarize the interaction history and use the new summary instead of the full history. Such agent can look like this:

[source,java,indent=0]
.{sample-base-url}/doc-snippets/src/main/java/com/example/application/CompactionAgent.java[CompactionAgent.java]
----
include::example$doc-snippets/src/main/java/com/example/application/CompactionAgent.java[tag=compaction]
----
<1> Instructions to create the summary of user and AI messages and result as JSON.
<2> The full history from the `SessionMemoryEntity`.
<3> Format and concatenate the messages.
<4> The `CompactionAgent` itself doesn't need any session memory.

One way to trigger compaction is to use a consumer of the session memory events and call the `CompactionAgent` from that consumer when a threshold is exceeded.

[source,java,indent=0]
.{sample-base-url}/doc-snippets/src/main/java/com/example/application/SessionMemoryConsumer.java[SessionMemoryConsumer.java]
----
include::example$doc-snippets/src/main/java/com/example/application/SessionMemoryConsumer.java[tag=compaction]
----
<1> The AiMessageAdded has the total size of the history.
<2> Retrieve the full history from the `SessionMemoryEntity`.
<3> Call the agent to make the summary.
<4> Store the summary as the new compacted history in the `SessionMemoryEntity`.
<5> To support concurrent updates, the `sequenceNumber` of the retrieved history is included in the `CompactionCmd`.


