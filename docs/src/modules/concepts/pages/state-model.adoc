= Memory models

include::ROOT:partial$include.adoc[]

Akka provides an in-memory, durable store for stateful data. This data may be scoped to a single agent or shared across the wider system. It is stored in an embedded event journal that captures changes incrementally. This approach helps the system recover to its most recent state if interrupted.

State is distributed across Akka nodes in a cluster. The platform manages sharding and rebalancing automatically to support scaling up to terabytes of memory. For added resilience, state may also be replicated across regions.

In Akka, memory is implemented as xref:java:event-sourced-entities.adoc[Event Sourced Entities]. Rather than storing the current state directly, Akka records a sequence of immutable events describing how state has changed. This provides a full picture of what has happened. The current state can always be restored by replaying the events. To improve recovery time, snapshots are taken along the way.

image:concepts:memory-event-journal.png[Memory Event Journal]

This model is used throughout Akka. For instance, when a xref:java:workflows.adoc[Workflow] is created, its call stack and internal state are stored as an Event Sourced Entity. This makes execution resilient, even across restarts.

image:concepts:workflow-event-journal.png[Workflow Event Journal]

Tracking state as a stream of events makes it possible to design agentic systems that are also event-driven architectures. Akka offers event subscription, brokerless messaging, and event replication. These features allow services to observe or respond to the state of other services, and also coordinate or synchronize across them.

image:concepts:event-uses.png[Event Uses]

Each xref:java:agents.adoc[Agent] in Akka includes short-term (traced and episodic) memory by default. This is implemented as a session-based, Event Sourced Entity. If you prefer, sessions can be made stateless so that no memory is retained after execution.

Long-term memory is implemented using the xref:java:event-sourced-entities.adoc[Event Sourced Entity] and xref:java:key-value-entities.adoc[Key Value Entity] components.

To propagate state across multiple systems, use the xref:java:views.adoc[View] component. Views are read-optimized projections that follow the Command Query Responsibility Segregation (CQRS) pattern.

== Entity state models

Entities are used to store the data defined in the xref:concepts:architecture-model.adoc#_domain[domain model]. They follow a specific __state model__ chosen by the developer. The state model determines how the data is organized and persisted. Entities have data fields that can be simple or primitive types like numbers, strings, booleans, and characters. The fields can be more complex, which allows custom types to be stored in Akka.

Entities have operations that can change their state. These operations are triggered asynchronously and implemented via methods that return xref:concepts:declarative-effects.adoc[`Effect`]. Operations allow entities to be dynamic and reflect the most up-to-date information and this all gets wired together for you.

Akka offers two state models: _Event Sourced Entity_ and _Key Value Entity_. Event Sourced Entities build their state incrementally by storing each update as an event, while Key Value Entities store their entire state as a single entry in a Key/Value store. To replicate state across clusters and regions, Akka uses specific conflict resolution strategies for each state model.

Event Sourced Entities, Key Value Entities and Workflows replicate their state by default. If you deploy your Service to a Project that spans multiple regions the state is replicated for you with no extra work to be done. By default, any region can read the data, and will do so from a local store within the region, but only the primary region will be able to perform writes. To make this easier, Akka will forward writes to the appropriate region.

To understand more about regions and distribution see xref:deployment-model.adoc#_region[Deployment model].

=== Identity

Each Entity instance has a unique id that distinguishes it from others. The id can have multiple parts, such as an address, serial number, or customer number. Akka handles concurrency for Entity instances by processing requests sequentially, one after the other, within the boundaries of a transaction. Akka proactively manages state, eliminating the need for techniques like lazy loading. For each state model, Akka uses a specific back-end data store, which cannot be configured.

==== Origin

Stateful entities in Akka have a concept of location, that is region, and are designed to span regions and replicate their data. For more information about regions see xref:concepts:deployment-model.adoc#_region[region] in the Akka deployment model.

Entities call the region they were created in their *origin* and keep track of it throughout their lifetime. This allows Akka to simplify some aspects of distributed state.

By default, most entities will only allow their origin region to change their state. To make this easier, Akka will automatically route state-changing operations to the origin region. This routing is asynchronous and durable, meaning network partitions will not stop the write from being queued. This gives you a read-anywhere model out of the box that automatically routes writes appropriately.

=== The Event Sourced state model

The Event Sourced state model captures changes to data by storing events in a journal. The current entity state is derived from the events. Interested parties can read the journal and transform the stream of events into read models (Views) or perform business actions based on events. 

image:event-sourced-entity-flow.svg[Concepts Events Source Flow]

A client sends a request to an Endpoint image:steps-1.svg[width=20]. The request is handled in the Endpoint which decides to send a command to the appropriate Event sourced  entity image:steps-2.svg[width=20], its identity is either determined from the request or by logic in the Endpoint.

The Event sourced entity processes the command image:steps-3.svg[width=20]. This command requires updating the Event sourced entity state. To update the state it emits events describing the state change. Akka stores these events in the event store image:steps-4.svg[width=20].

After successfully storing the events, the event sourced entity updates its state through its event handlers image:steps-5.svg[width=20].

The business logic also describes the reply as the commands effect which is passed back to the Endpoint image:steps-6.svg[width=20]. The Endpoint replies to the client when the reply is processed image:steps-7.svg[width=20].

NOTE: Event sourced entities express state changes as events that get applied to update the state.

=== The Key Value state model

In the _Key Value_ state model, only the current state of the Entity is persisted - its value. Akka caches the state to minimize data store access. Interested parties can subscribe to state changes emitted by a Key Value Entity and perform business actions based on those state changes. 

image:key-value-entity-flow.svg[Concepts Key Value Flow]

A client sends a request to an Endpoint image:steps-1.svg[width=20]. The request is handled in the Endpoint which decides to send a command to the appropriate Key Value entity image:steps-2.svg[width=20], its identity is either determined from the request or by logic in the Endpoint.

The Key Value entity processes the command image:steps-3.svg[width=20]. This command requires updating the Key Value entity state. To persist the new state of the Key Value entity, it returns an effect. Akka updates the full state in its persistent data store image:steps-4.svg[width=20].

The business logic also describes the reply as the commands effect which is passed back to the Endpoint image:steps-5.svg[width=20]. The Endpoint replies to the client when the reply is processed image:steps-6.svg[width=20].

NOTE: Key Value entities capture state as one single unit, they do not express state changes in events.

=== State models and replication

Event Sourced entities are replicated between all regions in an Akka project by default. This allows for a multi-reader capability, with writes automatically routed to the correct region based on the origin of the entity.

In order to have multi-writer (or write anywhere) capabilities you must implement a conflict-free replicated data type (CRDT) for your Event Sourced Entity. This allows data to be shared across multiple instances of an entity and is eventually consistent to provide high availability with low latency. The underlying CRDT semantics allow replicated Event Sourced Entity instances to update their state independently and concurrently and without coordination. The state changes will always converge without conflicts, but note that with the state being eventually consistent, reading the current data may return an out-of-date value.

NOTE: Although Key Value Entities are planned to support a Last Writer Wins (LWW) mechanism, this feature is not yet available.

== Related documentation

- xref:java:event-sourced-entities.adoc[Event Sourced Entities]
- xref:java:key-value-entities.adoc[Key Value Entities]
