= Project structure

include::ROOT:partial$include.adoc[]

Akka encourages a project structure that separates your system’s Application Programming Interfaces (APIs), Akka component logic, and business logic into different directories.

This structure supports a clear separation of concerns. It helps enable iterative development, testing in isolation, predictable packaging, and the ability to externalize configuration and static assets.

== Akka project structure

A typical Akka project might have a layout like the following:

[source,txt]
----
src/
 ├── main/
 │   ├── java/acme/planningagent/
 │   │   ├── api/           # External MCP, HTTP, gRPC endpoints
 │   │   ├── application/   # Akka components: Agents, Workflows, Entities, etc.
 │   │   └── domain/        # Business logic
 │   └── resources/
 └── test/
----

* The `api` directory exposes functionality to the outside world. This includes HTTP, gRPC, or MCP interfaces that forward requests to the application layer.
* The `application` directory contains the building blocks provided by Akka, implemented by you. It includes components such as `Agent`, `Entity`, `View`, `Workflow`, `Timer`, and `Consumer`.
* The `domain` directory holds plain Java classes that describe business rules and domain models. These are not tied to Akka or the runtime. Many use `record` to reduce boilerplate. You can test this logic without starting Akka or the runtime. This keeps the code focused and easier to maintain.
* The `resources` directory includes configuration files and other static content.
* The `test` directory contains unit and integration tests. Its structure mirrors `main` to make it easier to relate tests to the code they verify.

Keeping these areas distinct can help improve clarity and long-term maintainability. It also encourages testing and runtime separation.

== Conceptual layers

The structure above also reflects a conceptual separation of responsibilities. These responsibilities can be thought of as layers. Business logic is central, with supporting code around it to enable runtime behavior and external interaction.

To maintain modularity:

- Avoid exposing domain types directly to the outside world.
- The API layer should not call the domain layer directly.
- Inner layers should not depend on or be aware of outer layers.

For more on coding structure and practical considerations, see the xref:java:ai-coding-assistant-guidelines.adoc[coding guidelines].

=== Domain

This layer contains business rules and domain concepts. It does not depend on Akka or other runtime concerns. These are plain Java classes, often using `record` to reduce boilerplate. Examples include logic to enforce limits, compute totals, or apply rules.

You can write unit tests for this layer without needing to start Akka or the runtime. The domain package remains isolated, focused, and easy to change.

=== Application

This layer connects the domain model to the Akka runtime. It contains the components that handle persistence, coordination, and external interaction. These components follow event-driven patterns and manage state in a way that supports consistency and responsiveness.

Most classes in this layer are based on Akka-provided building blocks. The domain logic remains in the inner layer. This layer makes it operational.

=== API

This layer connects your service to the outside world. It defines endpoints that expose application functionality over HTTP or gRPC. Requests are handled here and passed on to the application layer.

Endpoints use xref:java:component-and-service-calls.adoc#_component_client[`ComponentClient`] to call Akka components in the application layer. This maintains separation of concerns and ensures runtime boundaries are respected.

The API layer may also expose public event models over Kafka or other channels. External systems should interact with your service only through this layer.

Access control and request validation also belong here. For HTTP-specific guidance, see xref:java:http-endpoints.adoc[Designing HTTP Endpoints].

== Akka services

image:ROOT:service.png[Services,width=50,float=left] A _Project_ may contain multiple _Services_. Projects can be deployed to one or more regions to achieve geographic resilience. For details, see xref:multi-region.adoc[]. Services are a hard boundary and unit of deployment in Akka projects.

=== Multi-service sharing

Code and components can also be shared between Akka services. There are a few guidelines to remember when setting up this kind of sharing in large, multi-service projects.

If you're following the recommended project structure, then your code should fall into one of three categories: _API_, _Application_, and _Domain_. 

Below is a list of some considerations you should keep in mind when sharing.

* ⚠️  **Entities** - Shared entities can make it easy for multiple services to agree on a set of events and commands. Be careful to avoid multiple, isolated entities sharing the same _internal_ state. Keep in mind that the same entity in different services will not share data. Akka will consider them two different entities with regard to persistence.
* ⚠️  **Views** - Views are easily shared. It may be useful to share views when you want multiple services to maintain the same aggregate data. When sharing views, keep an eye on your bounded contexts as it can be easy to blur those lines when multiple services maintain the same view. Also note that a shared view carries along with it all of the components it monitors for change.
* ⚠️  **Workflows** - Workflows contain a lot of business logic and are also easily reused. Before doing so, as with views, ask yourself why two services need to maintain the same workflow rather than having one service own a workflow exposed via an endpoint (endpoints can be internal only).
* ⚠️  **Endpoints** - Endpoints expose functionality to clients that can be internal or public, secure or wide open. As with all other components, identify why two services might need to expose the same endpoint? If they share the same endpoint, by extension they will share all of the code called by that endpoint. It can be easy to accidentally get an endpoint from a dependency and not notice. While it might seem useful to have two services with the same routes, sharing the entire endpoint also means sharing all of the involved components. +
You can design an endpoint class so that it is just a thin wrapper around an injected context, which then makes it easier to share the same routes but with different data and behavior.
* ✅  **Agents** - Agents are good candidates for sharing as two different services may need to perform the same agentic tasks but with different inputs.
* ✅  **MCP Tools** - Similar to shared agents, Akka makes it easy to create a shared class containing tool functions that can be available to multiple agents.
* ✅  **Domain classes** - The domain is the most ideal candidate for cross-service sharing. Multiple services using different views, entities, and workflows can safely rely on the same underlying set of domain objects (_not_ always the same as internal state).

Our recommendation is to start with a "share nothing" approach and then move to the domain level when appropriate. Only then consider other component types as candidates for sharing. Maintaining context boundaries and avoiding accidental sharing is key. 

== Next steps

Once familiar with the project structure, continue with:

- xref:deployment-model.adoc[Akka Deployment Model]
- xref:development-process.adoc[Development process]
- xref:state-model.adoc[]
- xref:java:dev-best-practices.adoc[Development best practices]

You may also begin development right away using the xref:java:index.adoc[Akka SDK].
