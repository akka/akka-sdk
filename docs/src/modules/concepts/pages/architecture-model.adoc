= Architecture model

include::ROOT:partial$include.adoc[]

Akka simplifies application development by allowing developers to focus on their domain models and APIs without worrying about how the data is stored. This document outlines the architecture of Akka applications. Links to further details will be at the end of this document. 

== Architecture

Akka applications are built with an _Onion Architecture_, where services are organized in concentric layers. The core of the application is at the center, with additional layers surrounding it. Each layer has a specific role.

image:docs-onion_architecture-v1.min.svg[]

=== Layers in the architecture

The layers of the Akka programming architecture are outlined below. These layers are generally all part of a single https://martinfowler.com/bliki/DDD_Aggregate.html[_aggregate root_] in Domain Driven Design parlance. That aggregate would be a package that would contain the following layers.

==== Domain

At the center is the _Domain Model_ which encapsulates your business logic. The domain should be mostly pure Java: that is not Akka components. In Akka projects and samples, this will often be a package called `domain`.

==== Application

The middle layer is the _Application layer_. This layer uses the domain model and coordinates domain objects. This layer is where your Akka components will live. In this sense, an Akka Component acts as the glue between your domain model and the Akka Runtime. This package will generally be called `application` and only contains Akka components like Entities and Views.

==== API

The outermost layer is the _API layer_, which connects your application to the outside world. This is the layer where you will define endpoints that expose your application layer. This package will generally be called `api`.

== Mechanics of each layer

Like most onion architectures, each layer only calls to the layers directly inside of it. This means an endpoint (API) will not directly call a domain object. It also means the outside world should never directly call domain objects or application components. If you want to call an Akka component like an entity or view, do so through an endpoint (`HttpEndpoint`). This separation is meant to contain the inner implementation and makes it easier to evolve applications over time.

These layers will generally be implemented as the three packages outlined above: `domain`, `application`, `api`. The mechanics of these layers are as follows.

=== Domain

Domain objects are independent of the other layers. As these are pure Java objects they are the place for implementing business logic. Examples of business logic include checking credit limits for a loan or return policy enforcement. You should write unit tests for this code that tests the business logic. 

Much of the inner loop of the developer experience will be spent here. Using Java's `record` type declaration simplifies the amount of ceremony involved in creating domain objects that are understood and used by Akka. This keeps your domain model clean and free of any dependencies - including Akka. 

=== Application

The application layer is where Akka really comes into play as the glue between your domain code and the runtime. Every class in this layer will extend an Akka component class (i.e. something in the `akka.javasdk` package) which means it will be event-based and actor-based behind the scenes, though you never have to really think about that. Akka components are marked with a `@ComponentId` annotation to identify them to the Runtime.

When you want to "do something", i.e. change state or take action, you implement methods in this layer with return type `Effect` or `ReadOnlyEffect`. The effects are signals to the runtime to persist your events: Akka will persist them for you and handle concurrent updates, scaling, and many other difficult tasks. This is a key part of what makes Akka so responsive and resilient. This model streamlines development and reduces the amount of ceremony you must perform to build Akka applications.

=== API

The outermost layer is the API layer which is how the outside world interacts with your application or service. In this layer, you define endpoints that expose your application. Each endpoint is marked with an `@HttpEndpoint` attribute, which allows the Runtime to build the appropriate endpoint URLs for uniquely identifying the components. Each public method on the endpoint that is annotated with method `@Get`, `@Post`, `@Put`, `@Patch` or `@Delete` serves those respective HTTP methods.

Having received requests, the `api` layer interacts with the `application` layer through the xref:java:component-and-service-calls.adoc#_component_client[`ComponentClient`] which makes calls in a type safe way. This is the layer boundary that keeps the isolation necessary to remain resilient that is core to an Akka application.

Additionally this layer is the place for a public event model that a service exposes, often via Kafka or other messaging capailities. This allows the event driven nature of Akka to be easily integrated into the rest of your information space. In Akka you don't reach into the database to get state, you use the event stream itself.

The API layer also uses other attributes to control access. For more information on endpoints see xref:java:http-endpoints.adoc[Designing HTTP Endpoints].

== Akka components

You use xref:reference:glossary.adoc#component[Akka _Components_] to build your application. These Components are crucial for ensuring responsiveness. Here is a brief overview of each. With the exception of endpoints, Akka components will live in your `application` package.

:TODO: add links to each component

=== Entities

_Entities_ are the core components of Akka and provide persistence and state management. They map to your https://martinfowler.com/bliki/DDD_Aggregate.html[_domain aggregates_]. If you have a "Customer" domain aggregate, you almost certainly will have a `CustomerEntity` component to expose and manipulate it. This separation of concerns allows the domain object to remain purely business logic focused while the Entity handles runtime mechanics. Additionally, you may have other domain objects that are leafs of the domain aggregate. These do not need their own entity if they are just a leaf of the aggregate. An address is a good example.

There are two types of entities in Akka. Their difference lies in how they internally function and are persisted.

==== Key Value Entities

_Key Value Entities_ are, as the name implies, an object that is stored and retrieved based on a key - an identifier of some sort. The value is the entire state of the object. Every write to a Key Value Entity persists the entire state of the object. Key Value Entities are similar in some ways to database records. They write and effectively lock the whole row. They still use an underlying event-based architecture so other components can subscribe to the stream of their updates. For more information see xref:java:key-value-entities.adoc[Key Value Entities].

==== Event Sourced Entities

Event Sourced Entities persist events instead of state in the event journal. The current state of the entity is derived from these events. Readers can access the event journal independently of the active entity instance to create read models, known as xref:java:views.adoc[_Views_], or to perform business actions based on the events via xref:java:consuming-producing.adoc[Consumers]. For more information, see xref:java:event-sourced-entities.adoc[Event Sourced Entities].

=== Views

_Views_ provide a way to materialize read only state from multiple entities based on a query. You can create views from Key Value Entities, Event Sourced Entities, and by subscribing to a topic. For more information see xref:java:views.adoc[Views].

=== Consumer

_Consumers_ listen for and process events or messages from various sources, such as Event Sourced Entities, Key Value Entities and external messaging systems. They can also produce messages to topics, facilitating communication and data flow between different services within an application. For more information see xref:java:consuming-producing.adoc[Consuming and producing].

=== Workflow

_Workflows_ enable the developer to implement long-running, multi-step business processes while focusing exclusively on domain and business logic. Technical concerns such as delivery guarantees, scaling, error handling and recovery are managed by Akka. xref:java:workflows.adoc[Workflows].

=== Timed actions

_Timed Actions_ allow for scheduling calls in the future. For example, to verify that some process have been completed or not. For more information see xref:java:timed-actions.adoc[Timed actions]

=== Endpoint

_Endpoints_ are defined points of interaction for services that allow external clients to communicate via standard HTTP methods like `GET`, `POST`, `PUT`, and `DELETE`. They facilitate the integration and communication between the other types of internal Akka components. Unlike other Akka components, endpoints will live in your `api` package. For more information on endpoints see xref:java:http-endpoints.adoc[HTTP Endpoints].

== Akka Services

A _Service_ is the base deployment unit in Akka. It contains the layers and packages described above. A service deploys to a Project. A project can contain more than one service and is tied to one or more regions. To learn more about deployment see xref:deployment-model.adoc[Akka Deployment Model].

== Next steps

Now that you understand the overall architecture of Akka you are ready to learn more about the xref:deployment-model.adoc[Akka Deployment Model]. 

The following topics may also be of interest.

- xref:development-process.adoc[Development process]
- xref:state-model.adoc[State model]
- xref:best-practices.adoc[Best practices]
- xref:control-tower.adoc[Monitoring and observability]

Start building your own Akka Service using the xref:java:index.adoc[Akka SDK].
