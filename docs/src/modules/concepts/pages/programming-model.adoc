= Programming model

include::ROOT:partial$include.adoc[]

Akka simplifies application development by allowing developers to focus on their domain models and APIs without worrying about how the data is stored.

As a developer, you are responsible for implementing the necessary _Components_ that encapsulate the state and business logic of the system you are building.

== Architecture
Akka supports building applications with the "Onion Architecture," where services are organized in concentric layers. The core of the application is at the center, with additional layers surrounding it. Each layer has a specific role.

:TODO: insert onion diagram here

=== Layers in the architecture
The layers of the Akka programming architecture are outlined below. These layers are generally all part of a single https://martinfowler.com/bliki/DDD_Aggregate.html[aggregate root] in Domain Driven Design parlance. That aggregate would be a package that would contain the following layers. 

==== Domain
At the center is the Domain Model which encapsulates your business logic. The domain should be mostly pure Java - that is not Akka components. In Akka projects and samples, this will often be a package called "domain".

==== Application
The middle layer is the Application layer. This layer uses the domain model and coordinates domain objects. This layer is where your Akka components will live. In this sense, an Akka Component acts as the glue between your domain model and the Akka Runtime. This package will generally be called "application" and only contains Akka components like entities and views.

==== API
The outermost layer is the API layer, which connects your application to the outside world. This is the layer where you will define endpoints that expose your application layer. This package will generally be called "api".

== Mechanics of each layer
Like most onion architectures, each layer only calls to the layer directly inside of it. This means an endpoint will not call a domain object. It also means the outside world should never directly call domain objects or application components. If you want to call an Akka component like an entity or view, do so through an endpoint. This separation is key to the responsive model of Akka.

These layers will generally be visible as the three packages outlined above: domain, application, api.

=== Domain
Domain objects are independent of the other layers. As these are pure Java objects they are the place for implementing business logic (need examples). You should write unit tests for this code that tests the business logic. Much of the inner loop of the developer experience will be spent here. Using Java's "record" type declaration simplifies the amount of ceremony involved in creating domain objects that are effectively plain data carriers. This keeps your domain model clean and free of any dependencies - including Akka. 

Akka is event based, so you will also define your business logic events in the domain layer.

=== Application

The application layer is where Akka really compes into play. Every class in this layer will extend an Akka class.

Akka is event-based, and this layer uses your domain objects to coordinate operations through xref:reference:glossary.adoc#effect[_Effects_]: notifications or events generated by the component. Effects do not impact the originating command / component directly. This helps abstract away the fact that there are no direct blocking or synchronous calls between the components in an Akka application. Methods that change state or take action will be Effects. This is a key part of what makes Akka so responsive and resilient. 

Akka components are marked with a `@ComponentId` annotation to identify them to the runtime. This avoids the ceremony of having to mark individual methods and classes with attributes. 

=== API
The outermost layer is the API layer, which connects your application to the outside world. In this layer, you define endpoints that expose your application. Each endpoint is marked with an `@HttpEndpoint` attribute, which allows the runtime to build the appropriate endpoint URLs for uniquely identifying the components. The API layer also uses other attributes to control access.

== Akka components
You will use Akka xref:reference:glossary.adoc#component[_Components_] to build your application. These Components are crucial for ensuring responsiveness. Here is a brief overview of each.

:TODO: add links to each component

=== Endpoint

Endpoints are defined points of interaction for services that allow external clients to communicate via standard HTTP methods like GET, POST, PUT, and DELETE. They facilitate the integration and communication between the other types of internal Akka components.

=== Entities


Entities are the core components of Akka and provide persistence and state management. They map to your domain model. If you have a "Customer" domain object, you almost certainly will have a `CustomerEntity` component to expose and manipulate it. This separation of concerns allows the domain object to remain purely business logic focused while the Entity handles runtime mechanics. There are two types of entities in Akka. Their difference lies in how they internally function and are persisted. 

==== KeyValueEntity
Key Value Entities are, as the name implies, an object that is stored and retrieved based on a key - an identifier of some sort. The value is the entire state of the object. Every write to a Key Value Entity persists the entire state of the object. Key Value Entities are similar in some ways to database records. They write and effectively lock the whole row. While still using an underlying event-based architecture, their writes are always the complete record. 

==== Event Sourced Entity
Event Sourced Entities persist their state using a journal of events. The current state of the entity is derived from these events. Readers can access the event journal independently of the active entity instance to create read models, known as xref:reference:glossary.adoc#view[_Views_], or to perform business actions based on the events.

=== Views
Views provide a way to materialize state from multiple entities based on a query. You can create views from Key Value Entities, Event Sourced Entities, and by subscribing to a topic.

=== Consumer

Consumers listen for and process events or messages from various sources, such as Event Sourced Entities, Key Value Entities and external messaging systems. They can also produce messages to topics, facilitating communication and data flow between different services within an application.

=== Workflow
Workflows enable the developer to implement long-running, multi-step business processes while focusing exclusively on domain and business logic. Technical concerns such as delivery guarantees, scaling, error handling and recovery are managed by Akka.

=== Timed actions
Timers allow for scheduling calls in the future. For example, to verify that some process have been completed or not.

== Akka Services
A _Service_ is the base deployment unit in Akka. It contains the layers and packages described above. A service deploys to a Project. A project can contain more than one service and is tied to one or more regions.

:TODO: link all of these things

== Next steps

Start building your own Akka Service using the xref:java:index.adoc[Akka SDK]
