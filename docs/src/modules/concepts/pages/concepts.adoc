= Concepts

include::ROOT:partial$include.adoc[]

include::ROOT:partial$concepts-intro.adoc[]

== Akka’s design goals

Akka’s design principles are influenced by decades of distributed systems research.

[cols="1,3", options="header"]
[.compact]
|===
|Research |Publications

|Patterns
|link:https://www.oreilly.com/library/view/principles-and-patterns/9781098181260/[Principles and Patterns for Distributed Application Architecture, window="new"]

|Principles
|link:https://www.reactiveprinciples.org/[The Reactive Principles, window="new"]

|Approach
|link:https://www.reactivemanifesto.org/[The Reactive Manifesto, window="new"]
|===

The Akka Agentic Platform contains an SDK for development, the Akka runtime for scalable and resilient execution, and multiple operating modes. The platform, from development to production, has its own design goals.

[cols="1,3", options="header"]
[.compact]
|===
|Property |Our Design Philosophy

|Simple
|Development approachable by anyone with (and eventually without) coding skills.

|Adaptable
|Runtime that adapts to environment or system changes by embracing failure and uncertainty.

|Elastic
|Scale processing and data (i.e. memory) to any level by distributing compute and state across Akka nodes.

|Resilient
|Recover from any failure, whether hardware, network, or hallucination.

|Interoperable
|Across all Akka components, any 3rd party system, protocol, broker, or Application Programming Interface (API).

|Composable
|Akka services and components can be combined to create systems of any complexity.

|Production-ready
|Akka services should never require code changes when moving into production.
|===

== Anatomy of an autonomous agentic AI system

An autonomous agentic AI system consists of the following behaviors:

[horizontal]
Agents:: Active components that pursue goals by observing input, making decisions, and taking action. May be stateful or stateless. Often orchestrate workflows, interact with memory, or invoke tools.
Tools:: External systems, APIs, or functions that agents can call to perform tasks beyond their own capabilities, such as querying a database or triggering an external service.
Goals:: Define the desired outcome or intent of an agent. Goals guide reasoning and determine what success looks like for a given task or interaction.
Guardians:: Enforce constraints or boundaries on behavior. Guardians ensure the agent stays within acceptable, ethical, or operational limits, even as it explores solutions autonomously.
Adaptation:: Enables the agent to adjust its strategy in response to changing inputs, failure states, or unexpected outcomes. A hallmark of resilient systems.
Coordination:: Allows agents to interact with other agents, users, tools, or services in a coherent way. Coordination is essential for sequencing actions, sharing context, or achieving group-level outcomes.
Shared State (memory):: Provides continuity across invocations, sessions, or agents. Shared state allows the system to retain knowledge, track decisions, and synchronize behavior in distributed environments.

== Properties of a distributed system

A distributed system is any system that distributes logic or state. Distributed systems embody certain principles that when combined together create a system that achieves responsiveness. Distributed systems are capable of operating in any location: locally on your development machine, in the cloud, at the edge, embedded within a device, or a blend of all.

[cols="1,3", options="header"]
[.compact]
|===
| Property     | Definition
| Elasticity
| The system can automatically adjust its resources, scaling up or down to efficiently handle changes in workload.
| Resilience
| The system continues to function and recover quickly, even when parts of it fail, ensuring ongoing availability.
| Agility
| The system can easily adapt to new requirements or changes in its environment with minimal effort.
| Responsiveness
| Most importantly, the system consistently responds to users and events in a timely manner, maintaining a reliable experience.
|===

== Akka components

Akka provides a basket of interoperable components that can be used to design and implement any potential autonomous agentic AI (or distributed) system.

[cols="1,3", options="header"]
[.compact]
|===
|Component |Description

|Agents
|Performs one focused AI task using a selected model and prompt. Can hold context with session memory (stateful) or run stateless with no retained history.

|Workflows
|Durable execution with support for sequential, parallel, looping, retry, and failure logic.

|HTTP Endpoints
|Exposes APIs over Hypertext Transfer Protocol (HTTP). Processes input, triggers components, shapes responses, and returns results.

|gRPC Endpoints
|Exposes APIs over gRPC Remote Procedure Calls (gRPC). Uses Protobuf contracts to ensure compatibility. Handles input, triggers logic, and returns results. 

|MCP Endpoints
|Exposes tools, resources, and prompts over Model Context Protocol (MCP) protocol. Enables agents to invoke logic, retrieve data, and establish context.

|Entities (memory)
|Long term durable memory accessible by multiple agents, users, APIs, or 3rd party systems.

|Views
|Indexes and queries entity data across IDs or attributes. Built from entity state or events. Enables efficient lookups, filtering, and real-time updates.

|Consumers (streaming)
|Subscribes to and processes event streams or messages from entities, workflows, or external systems.

|Timers
|Schedules future calls with at-least-once delivery. Useful for deferred actions, retries, and timeouts. 
|===

== Component interoperability

Akka components can communicate seamlessly, regardless of physical location. Location transparency ensures efficient message routing and runtime efficiency, even across network boundaries.

There are two main modes of inter-component communication in Akka:

1. **ComponentClient**: Asynchronous, non-blocking invocations. Components return immediately after dispatching a message, regardless of destination.

2. **Events**: Components emit events that others may subscribe to. This pattern enables decoupled, brokerless messaging similar to pub/sub systems. Akka components may also subscribe to events from external sources (e.g., APIs, brokers).

== Packaging flexibility

Akka provides flexibility in how services are assembled and deployed. Whether you start with a small proof of concept or a larger system, you can choose the structure that fits your needs.

image:concepts:packed-services.png[Akka Packaging]

It is possible to package a single service with one component, or combine multiple services, each composed of several components, into a single deployable binary.

This approach makes it easy to co-locate logic where it makes sense, while still keeping services modular in design. You are free to choose what to group together without being locked into a single pattern.

Once packaged, you can run any number of instances of the binary. These instances operate in a variety of environments, including containers, virtual machines, Kubernetes, or edge deployments. They automatically discover each other and form a cluster without requiring additional configuration.

This packaging supports a range of operational models:

[cols="1,3", options="header"]
[.compact]
|===
| Operational model | Description

| Local development
| Run one or more instances using Docker Compose or Kubernetes. Useful for testing full system behavior locally.

| Self-managed
| Operate on your own infrastructure with full control over networking, persistence, and deployment routines.

| Akka Cloud
| A managed environment that handles scaling, clustering, persistence, and operational automation.
|===

This flexibility allows teams to start simply, with everything in one place, and evolve naturally as needs change. Services remain modular in code, even when packaged together, resulting in a system prepared for scale.

== Agentic runtimes

Autonomous AI systems require three types of runtimes:

[cols="1,3", options="header"]
[.compact]
|===
|Runtime |Description
|Durable Execution
|Long-lived, where the call-stack is persisted after every invocation to enable recovery and retries.

This is utilized when you implement the xref:java:workflows.adoc[Workflow] component.

|Transactional
|Short-lived, high volume, concurrent execution.

This is utilized when you implement xref:concepts:grpc-vs-http-endpoints.adoc[Endpoint], xref:java:views.adoc[View], xref:concepts:state-model.adoc[Entity] and xref:java:timed-actions.adoc[Timer] components.
|Streaming
|Continuous, never-ending processes that handle streams of data.

This is utilized when you implement the xref:java:consuming-producing.adoc[Consumer] component or xref:concepts:grpc-vs-http-endpoints.adoc[SSE / gRPC streaming extension of an endpoint].
|===

Akka provides support for all three runtimes within the same SDK. The runtime behavior is automatic within your service based upon the components that you use during development. All of these runtimes leverage an actor-based core, which is a concurrency model with strong isolation and asynchronous message passing between actors. When running a service that executes multiple runtimes, Akka maximizes efficiency of the underlying compute by executing actors for different runtimes concurrently, enabling node resource utilization up to 95%.

== Shared and distributed state (memory)

Akka fulfills all shared data (memory) requirements for agentic AI systems.

[cols="1,1,3", width=85%]
[.compact]
|===
| Type | Provided by | Description
| Agentic | Akka Agent component (automatic for every agent) | Tracks the intermediate steps within a single agent loop. For instance, if an agent invokes three tools before producing a result, agentic memory captures each interaction in that chain. Useful for auditability, tool orchestration and introspection. This is managed automatically by Akka and requires no manual instrumentation.
| Episodic | Akka Agent component (automatic for every agent) | Often called short-term or session memory. Captures conversational history between a single user and an agent during a session. Automatically tracked if an agent is marked as stateful.
| Long-term | Akka Entity component | Represents memory accumulated over many sessions with the same user and agent. Often stored in summarized or aggregated form.
| External | Akka Entity component | Shared memory across agents, users, or systems. This state is durable. Useful for collaborative systems or shared business context.
|===

Akka handles all state as event sourced. Events are recorded sequentially and durably, forming a transparent log of changes. This enables persistence, import/export, replication, and replay without requiring extra work from the developer.

The runtime scales memory across millions of nodes and regions. Failover is supported with replication and low recovery times, typically under 200ms.

== Service clustering

Akka supports horizontal scaling across clustered services. Multiple instances can be launched as needed. Operational tasks are automated by Akka Platform, or may be performed manually in a self-managed environment if desired.