= Foundations of Akka agentic AI systems

include::ROOT:partial$include.adoc[]

include::ROOT:partial$concepts-intro.adoc[]

== Akka’s design goals

Akka’s design principles are influenced by decades of distributed systems research.

[cols="1,3", options="header"]
|===
|Research |Publications

|Patterns
|link:https://www.oreilly.com/library/view/principles-and-patterns/9781098181260/[Principles and Patterns for Distributed Application Architecture, window="new"]

|Principles
|link:https://www.reactiveprinciples.org/[The Reactive Principles, window="new"]

|Approach
|link:https://www.reactivemanifesto.org/[The Reactive Manifesto, window="new"]
|===

The Akka Agentic Platform contains an SDK for development, the Akka runtime for scalable and resilient execution, and multiple operating modes. The platform, from development to production, has its own design goals.

[cols="1,3", options="header"]
|===
|Property |Our Design Philosophy

|Simple
|Development approachable by anyone with (and eventually without) coding skills.

|Adaptable
|Runtime that adapts to environment or system changes by embracing failure and uncertainty.

|Elastic
|Scale processing and data (i.e. memory) to any level by distributing compute and state across Akka nodes.

|Resilient
|Recover from any failure, whether hardware, network, or hallucination.

|Interoperable
|Across all Akka components, any 3rd party system, protocol, broker, or API.

|Composable
|Akka services and components can be combined to create systems of any complexity.

|Production-ready
|Akka services should never require code changes when moving into production.
|===

== Anatomy of an Agentic system

An agentic system is a distributed system that requires a variety of behaviors and infrastructure.

image:concepts:agentic-ai-system-anatomy.png[Akka Agentic Platform]

[cols="1,3", options="header"]
|===
|Aspect |AI Role and Responsibility

|Agents
|Components that integrate with AI to perceive their environment, make decisions and take actions toward a specific goal

You implement agents in Akka with the xref:java:agents.adoc[Agent] component.

|Tools
|Functionality, local or remote, that agents may call upon to perform tasks beyond their core logic.

You invoke tools in Akka through _embedded agent function calls_ or by _invoking a remote MCP tool_. You can implement MCP servers with the xref:java:mcp-endpoints.adoc[MCP Endpoints] component.

|Endpoints
|Externally accessible entry points through which agents are launched and controlled.

You implement Endpoints in Akka using either xref:java:http-endpoints.adoc[HTTP], xref:java:grpc-endpoints.adoc[gRPC] or xref:java:mcp-endpoints.adoc[MCP] Endpoint components.

|Goals
|Clear objectives or outcomes that agents continuously work toward by making decisions and taking actions on their own.

You implement goals in Akka by implementing a multi-agent system _with a planner agent_ using a xref:java:workflows.adoc[Workflow] component to orchestrate the cross-agent interactions.

|Guardians
|Components that monitor, protect and evaluate the system against its goals and constraints. 

You will soon be able to implements guardians in Akka with an xref:java:agents.adoc#_evaluating_ai_model_quality[Agent evaluation workbench].
|Adaptation
|Continuous, real-time streams from users or the environment which can alter the context, memory or semantic knowledge used by an agentic system.

You implement adaptation in Akka by processing a stream of data from external sensors, either with the xref:java:consuming-producing.adoc[Consumer] component or through streaming HTTP or gRPC interfaces. xref:java:consuming-producing.adoc[Consumers] can modify an agent’s goals, memory, or guardians to affect the behavior of the system.

|Orchestration
|The ability to execute, persist and recover long-running tasks made possible through _durable execution_.

You implement orchestration in Akka with the xref:java:workflows.adoc[Workflow] component.

|Memory
|Data that enables agents to reason over time, track context, make correct decisions and learn from experience.

You inherit agentic and episodic (short-term) durable memory automatically when you implement a stateful xref:java:agents.adoc[Agent] component. You can get long-term, multi-agent memory by implementing xref:java:event-sourced-entities.adoc[Event Sourced Entity] or xref:java:key-value-entities.adoc[Key Value Entity] components.

|Registry
|A built-in directory that stores information about all agents so they can be discovered and called upon in multi-agent systems.

You use the registry provided by Akka by xref:java:agents.adoc#_creating_dynamic_plans[annotating each agent], which allows Akka to automatically register and use them as needed.
|===

== Properties of a distributed system

A distributed system is any system that distributes logic or state. Distributed systems embody certain principles that when combined together create a system that achieves responsiveness. Distributed systems are capable of operating in any location: locally on your development machine, in the cloud, at the edge, embedded within a device, or a blend of all.

[cols="1,3", options="header"]
|===
| Property     | Definition
| Elasticity
| The system can automatically adjust its resources, scaling up or down to efficiently handle changes in workload.
| Resilience
| The system continues to function and recover quickly, even when parts of it fail, ensuring ongoing availability.
| Agility
| The system can easily adapt to new requirements or changes in its environment with minimal effort.
| Responsiveness
| Most importantly, the system consistently responds to users and events in a timely manner, maintaining a reliable experience.
|===

== Autonomous AI runtimes

Akka supports three fundamental runtime types:

1. Durable execution
* Long-lived
* Persists the call stack after every invocation
* Enables recovery and retry mechanisms

2. Transactional
* Short-lived
* High-throughput, concurrent processing

3. Streaming
* Never-ending
* Continuous execution of data streams

Akka combines all three runtime types into a single engine. This allows for high resource utilization (up to 95%) without impacting performance.

== Akka components

Akka provides composable building blocks suitable for constructing agentic AI or distributed systems:

[horizontal]
Agents:: Stateful or stateless processing units
Workflows:: Durable execution with control flow support
Endpoints:: Interfaces for API communication
Entities:: Durable memory stores
Views:: Read-optimized projections
Consumers:: Streaming data processors
Timers:: Time-based triggers

== Component interoperability

Akka components can communicate seamlessly, regardless of physical location. Location transparency ensures efficient message routing and runtime efficiency, even across network boundaries.

There are two main modes of inter-component communication in Akka:

1. **ComponentClient**: Asynchronous, non-blocking invocations. Components return immediately after dispatching a message, regardless of destination.

2. **Events**: Components emit events that others may subscribe to. This pattern enables decoupled, brokerless messaging similar to pub/sub systems. Akka components may also subscribe to events from external sources (e.g., APIs, brokers).

== Component composability

Components can be connected in flexible arrangements, offering creative freedom in system design.

Examples of component connections include:
[horizontal]
Endpoint → Agent:: An API endpoint that invokes an agent for processing.
Endpoint → Workflow:: An API endpoint that triggers a workflow for complex tasks.
Workflow → Agent:: A workflow that orchestrates an agent to perform specific actions.
Agent → Agent:: An agent that delegates tasks to another agent.
Agent → Entity:: An agent that interacts with an entity to store or retrieve data.
Agent → View:: An agent that updates a view with processed data.
Stream → Consumer:: A data stream that is processed by a consumer component.

The possibilities are only limited by the developer's imagination. Akka's composable design encourages experimentation and evolution in system architecture.

== Shared and distributed state (memory)

Akka fulfills all shared data (memory) requirements for agentic AI systems.

[cols="1,1,3", width=85%]
|===
| Type | Provided by | Description
| Agentic | Akka Agent component (automatic for every agent) | Tracks the intermediate steps within a single agent loop. For instance, if an agent invokes three tools before producing a result, agentic memory captures each interaction in that chain. Useful for auditability, tool orchestration and introspection. This is managed automatically by Akka and requires no manual instrumentation.
| Episodic | Akka Agent component (automatic for every agent) | Often called short-term or session memory. Captures conversational history between a single user and an agent during a session. Automatically tracked if an agent is marked as stateful.
| Long-term | Akka Entity component | Represents memory accumulated over many sessions with the same user and agent. Often stored in summarized or aggregated form.
| External | Akka Entity component | Shared memory across agents, users, or systems. This state is durable. Useful for collaborative systems or shared business context.
|===

Akka handles all state as event sourced. Events are recorded sequentially and durably, forming a transparent log of changes. This enables persistence, import/export, replication, and replay without requiring extra work from the developer.

The runtime scales memory across millions of nodes and regions. Failover is supported with replication and low recovery times, typically under 200ms.

== Service clustering

Akka supports horizontal scaling across clustered services. Multiple instances can be launched as needed. Operational tasks are automated by Akka Platform, or may be performed manually in a self-managed environment if desired.