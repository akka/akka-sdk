= Foundations of Akka agentic AI systems

include::ROOT:partial$include.adoc[]

include::ROOT:partial$concepts-intro.adoc[]

== Akka’s design goals

Akka’s design principles are influenced by decades of distributed systems research.

[cols="1,3", options="header"]
|===
|Research |Publications

|Patterns
|link:https://www.oreilly.com/library/view/principles-and-patterns/9781098181260/[Principles and Patterns for Distributed Application Architecture, window="new"]

|Principles
|link:https://www.reactiveprinciples.org/[The Reactive Principles, window="new"]

|Approach
|link:https://www.reactivemanifesto.org/[The Reactive Manifesto, window="new"]
|===

The Akka Agentic Platform contains an SDK for development, the Akka runtime for scalable and resilient execution, and multiple operating modes. The platform, from development to production, has its own design goals.

[cols="1,3", options="header"]
|===
|Property |Our Design Philosophy

|Simple
|Development approachable by anyone with (and eventually without) coding skills.

|Adaptable
|Runtime that adapts to environment or system changes by embracing failure and uncertainty.

|Elastic
|Scale processing and data (i.e. memory) to any level by distributing compute and state across Akka nodes.

|Resilient
|Recover from any failure, whether hardware, network, or hallucination.

|Interoperable
|Across all Akka components, any 3rd party system, protocol, broker, or API.

|Composable
|Akka services and components can be combined to create systems of any complexity.

|Production-ready
|Akka services should never require code changes when moving into production.
|===

== Anatomy of an autonomous agentic AI system

An autonomous agentic AI system consists of the following behaviors:

[horizontal]
Agents:: Active components that pursue goals by observing input, making decisions, and taking action. May be stateful or stateless. Often orchestrate workflows, interact with memory, or invoke tools.
Tools:: External systems, APIs, or functions that agents can call to perform tasks beyond their own capabilities, such as querying a database or triggering an external service.
Goals:: Define the desired outcome or intent of an agent. Goals guide reasoning and determine what success looks like for a given task or interaction.
Guardians:: Enforce constraints or boundaries on behavior. Guardians ensure the agent stays within acceptable, ethical, or operational limits, even as it explores solutions autonomously.
Adaptation:: Enables the agent to adjust its strategy in response to changing inputs, failure states, or unexpected outcomes. A hallmark of resilient systems.
Coordination:: Allows agents to interact with other agents, users, tools, or services in a coherent way. Coordination is essential for sequencing actions, sharing context, or achieving group-level outcomes.
Shared State (memory):: Provides continuity across invocations, sessions, or agents. Shared state allows the system to retain knowledge, track decisions, and synchronize behavior in distributed environments.

== Properties of a distributed system

A distributed system is any system that distributes logic or state. Distributed systems embody certain principles that when combined together create a system that achieves responsiveness. Distributed systems are capable of operating in any location: locally on your development machine, in the cloud, at the edge, embedded within a device, or a blend of all.

[cols="1,3", options="header"]
|===
| Property     | Definition
| Elasticity
| The system can automatically adjust its resources, scaling up or down to efficiently handle changes in workload.
| Resilience
| The system continues to function and recover quickly, even when parts of it fail, ensuring ongoing availability.
| Agility
| The system can easily adapt to new requirements or changes in its environment with minimal effort.
| Responsiveness
| Most importantly, the system consistently responds to users and events in a timely manner, maintaining a reliable experience.
|===

== Autonomous AI runtimes

Akka supports three fundamental runtime types:

1. Durable execution
* Long-lived
* Persists the call stack after every invocation
* Enables recovery and retry mechanisms

2. Transactional
* Short-lived
* High-throughput, concurrent processing

3. Streaming
* Never-ending
* Continuous execution of data streams

Akka combines all three runtime types into a single engine. This allows for high resource utilization (up to 95%) without impacting performance.

== Akka components

Akka provides composable building blocks suitable for constructing agentic AI or distributed systems:

[horizontal]
Agents:: Stateful or stateless processing units
Workflows:: Durable execution with control flow support
Endpoints:: Interfaces for API communication
Entities:: Durable memory stores
Views:: Read-optimized projections
Consumers:: Streaming data processors
Timers:: Time-based triggers

== Component interoperability

Akka components are able to interoperate with one another regardless of where the component may be executing. While you create systems that define the relationships between each of the components in code, at runtime instances of each component can run on different nodes. The Akka runtime provides location transparency, automating the routing of a call from one component to another even if they reside in different locations on different networks.

There are two ways to achieve interoperability between Akka components and the outside world.


[cols="1,3", options="header"]
[.compact]
|===
|Client Type |Description

|xref:java:component-and-service-calls.adoc[ComponentClient]
|One component can directly invoke another component. Akka treats these direct invocations as non-blocking, asynchronous messages, meaning that the invoking component immediately returns after making the invocation and can invoke any component regardless of its location.

For example, a Workflow component handling a long-running business transaction can invoke an Agent component to perform a task, and the Workflow can continue processing without waiting for the Agent to complete its work.

|Events
|Components can emit events that can be subscribed to by other components. For example, an entity can emit an event when its state is updated. Other components can subscribe to this event, similar to how clients subscribe to Kafka topics. Events are propagated transparently between components through reliable, brokerless messaging.

Components can also subscribe to events that are incoming from external sources, which can be 3rd party brokers, APIs, or real-time streams of data.
|===

Akka is designed so that components remain loosely coupled and can communicate with each other regardless of where they run. Inter-component communication runs on virtual threads managed by the Akka runtime. These threads are lightweight and isolated in a way that ensures system resources remain available for other tasks. This allows components to interact without interfering with each other or affecting overall responsiveness. This basic behavior is one reason why Akka services, whether stateful or stateless, can scale to 10M transaction per second (TPS).

[cols="2,3", options="header"]
[.compact]
|===
| Example Interoperability | Description

| Endpoint → Workflow → Agent + 
  Endpoint → Entity → View     | A user triggers an HTTP request to start a long-running Workflow. The Workflow manages file processing and passes relevant data or control to an Agent, which will later use it for answering questions. Meanwhile, another Endpoint saves user interaction history into an Entity. A View component then reads from that Entity to reconstruct the user’s conversation history for display or retrieval.

| Endpoint → Agent → Entity → View +
  Endpoint → Workflow → Entity       | A user sends a query to an Endpoint. An Agent processes the query and stores the interaction in an Entity. A View then reads this data to reconstruct the conversation history for that user. Meanwhile, an Endpoint starts a Workflow. The Workflow processes input data and stores results into an Entity.


| Stream → Consumer → Entity +
  Agent → Endpoint → Entity        | A data stream is received by a Consumer, which writes the structured data to an Entity for long-term storage and future retrieval. Meanwhile, an Agent invokes some logic exposed by an Endpoint, and persists the result in an Entity.

|===

== Component composability

Components can be connected in flexible arrangements, offering creative freedom in system design.

Examples of component connections include:
[horizontal]
Endpoint → Agent:: An API endpoint that invokes an agent for processing.
Endpoint → Workflow:: An API endpoint that triggers a workflow for complex tasks.
Workflow → Agent:: A workflow that orchestrates an agent to perform specific actions.
Agent → Agent:: An agent that delegates tasks to another agent.
Agent → Entity:: An agent that interacts with an entity to store or retrieve data.
Agent → View:: An agent that updates a view with processed data.
Stream → Consumer:: A data stream that is processed by a consumer component.

The possibilities are only limited by the developer's imagination. Akka's composable design encourages experimentation and evolution in system architecture.

== Shared and distributed state (memory)

Akka fulfills all shared data (memory) requirements for agentic AI systems.

[cols="1,1,3", width=85%]
|===
| Type | Provided by | Description
| Agentic | Akka Agent component (automatic for every agent) | Tracks the intermediate steps within a single agent loop. For instance, if an agent invokes three tools before producing a result, agentic memory captures each interaction in that chain. Useful for auditability, tool orchestration and introspection. This is managed automatically by Akka and requires no manual instrumentation.
| Episodic | Akka Agent component (automatic for every agent) | Often called short-term or session memory. Captures conversational history between a single user and an agent during a session. Automatically tracked if an agent is marked as stateful.
| Long-term | Akka Entity component | Represents memory accumulated over many sessions with the same user and agent. Often stored in summarized or aggregated form.
| External | Akka Entity component | Shared memory across agents, users, or systems. This state is durable. Useful for collaborative systems or shared business context.
|===

Akka handles all state as event sourced. Events are recorded sequentially and durably, forming a transparent log of changes. This enables persistence, import/export, replication, and replay without requiring extra work from the developer.

The runtime scales memory across millions of nodes and regions. Failover is supported with replication and low recovery times, typically under 200ms.

== Service clustering

Akka supports horizontal scaling across clustered services. Multiple instances can be launched as needed. Operational tasks are automated by Akka Platform, or may be performed manually in a self-managed environment if desired.